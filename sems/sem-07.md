# Object-oriented programming
## Constructor

Рассмотрим класс T:
* ```c++ explicit T(U other)``` - запретить неявное приведение типов от U к T
* ```c++ explicit operator bool() const { ... }``` - запретить неявное приведение типа T к bool
* member initializer lists позволяет проинициализировать перемнные "до" тела конструктора, т.е., например, можно проиницилизировать поле с типом ```c++ const int&```, а в теле уже нельзя. Поля инициализируются **всегда** в порядке объявления.
* Если ни один конструктор не объявлен, то компилятор создает неявный конструктор.
* ```c++ T() = default;``` создает конструктор по умолчанию, **неэквивалентно** ```c++ T() = {}```. В первом случае класс остается [trivial](https://en.cppreference.com/w/cpp/named_req/TrivialType). В некоторых случаях компилятор заменяет default на delete, например, когда есть поле ```c++ const int&```.
* ```c++ T() = delete;``` - позволяет удалить конструктор, в некоторых случаях имеет смысл сделать конструктор приватным, например, для класса Singleton (см. ниже).

```c++
class Singleton {
public:
    static Singleton& instance() {
        static Singleton object;
        return object;
    }
private:
    Singleton() = default;
}
```

## Operator
Некоторые операторы можно перегружать. [Подробнее тут](https://en.cppreference.com/w/cpp/language/operators).
Рассмотрим базовые идеи на основе класса String.

* const, & qualifiers. Позволяет указать у метода ограничения на *this*. У объекта с типом const String можно вызывать только const методы. Идейно методы с & qualifier можно вызывать только от объектов, от которых можно взять ссылку. Более формально обсудим, когда пройдем lvalue/rvalue... Это полезно, например, в ```c++ String& operator=(const String& other)```, чтобы запрещать конструкции вида ```c++ a + b = c```.
* operator+ лучше реализовывать через ```operator+=``` для избежания лишнего копирования. А также вне класса, чтобы не было ограничения на левый типа класса от оператора.
* [RVO](https://en.cppreference.com/w/cpp/language/copy_elision). Из-за этой оптимизации стоит помочь компилятору и в ```c++ operator+```возвращать не ```c++ return a += b;``` так как возвращаемое значение String& у operator+=.

## operator<=>
```c++ auto operator<=>(const T& other) = default;``` Реализует оператор <=>, тип возвращаемого значения ```c++ std::strong_ordering```. Constants: less, equivalent, equal, greater. Реализация по умолчанию производит сравнение лексиграфически по полям класса. Можно сделать свою реализацию.

Благодаря этому операцию появляется возможность для всех 6 операторов: <, >, <=, >=, ==, !=. Компилятор заменяет выражение `a @ b` на `(a <=> b) @ 0`.

## operator==
TLDR;
