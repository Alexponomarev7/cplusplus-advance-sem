# Debug. LLDB/GDB

## printf

TLDR;

## GDB/LLDB

GDB - утилита для отладки под лицензией GNU.
LLDB - утилита из семейства LLVM. Из-за архитектурных особенностей LLVM как показывает практика наблюдается более стабильная работа LLDB в сравнение с GDB.

[DWARF](https://habr.com/ru/post/199490/) - это стандартизованный формат отладочной информации.

[Compiler explorer](https://godbolt.org/) - TLDR;

## Debug build

Для того, чтобы отладка под GDB работала корректно необходима отладочная информация, это реализует флаг `-g`. Оптимизации могут приводить к большому рассхождению отладочной информации и скомпилированной программы. Чем выше уровнень оптимизации, тем больше странного поведения может наблюдаться. Поэтому рекомендованный типичный кейс использования там, где это возможно: `g++ -O0 -g main.cpp -o main`. Практика показывает, что также `g++ -O1 -fno-inline-functions -g main.cpp -o main` также имеет быть.

## Breakpoint

Breakpoint - ключевое понятие в отладке, место в программе, где мы хотим остановить выполнение. Реализовано через механизм прерываний.

Допустим у нас была следующая функция func.

```asm
func:
    push   rbp      // 55
    mov    rbp,rsp  // 48 89 e5
    mov    eax,0x0  // b8 00 00 00 00 
    ret             // c3
```

Мы хотим поставить breakpoint на вход в нёё, gdb преобразует её код в следующее:

```asm
func:
    int3            // cc -> gdb запоминает byte, который заменил, а именно 0x55
    mov    rbp,rsp  // 48 89 e5
    mov    eax,0x0  // b8 00 00 00 00 
    ret             // c3
```

Срабатывает обработчик прерывания и мы попадаем в gdb shell, gdb возвращает измененный байт.

* b function - установить breakpoint на начало исполнения функции function.
* b main.cpp:40 - установить breakpoint на строчку в файле.
* b ... if var==123 - установить breakpoint при выполнения условия. Переменные достаются из области вызова breakpoint'а.
* rbreak regex - установить beakpoint'ы по регулярному выражению.
* tbreak ... - устновить временный breakpoint (удаляется после первого просматривания).
* info b - просмотреть информацию по всем breakpoint
* delete #id - удалить breakpoint c номером #id
* enable/disable #id - включить/выключить breakpoint с номером #id
* command #id - установить комманду при срабатывании этого breakpoint

## GDB shell

* gdb prog --args 1 2 3 - запустить gdb для prog с параметрами коммандной строки `1 2 3`.
* gdb --pid 123 - запустить gdb для рабочего процесса с pid 123.
* run ... - запустить исполнение программы. Тут может любой валидный bash-script. Например, `run 1 2 3 <input.txt`.
* start - запустить исполнение программы
* enter повторяет последнюю команду
* bt - узнать backtrace в текущем месте исполнения
* i locals - узнать текущие переменные области видимости 
* layout src
* layout regs
* record
* reverse-stepi
* set $eax
* record stop

TLDR;

## GDB stepping

* s - сделать шаг исполнения программы
* n - сделать шаг исполнения программы **без захода в вызовы функции**
* c - продолжить исполнение программы до следующего breakoint
* f - закончить исполнение программы